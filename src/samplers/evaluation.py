import csv
from pathlib import Path
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
from skbio.stats.ordination import pcoa
from scipy.spatial.distance import pdist, squareform
from skbio.stats.distance import DistanceMatrix, permanova



def eval_healthy_and_synthetic(healthy_prop, synth_prop, eps_vec=None, method_string="", fraction=1, random_state=42):
    """
    Evaluate and print statistics comparing healthy_prop and synth_prop.
    Currently dispatches to PCOA evaluation.
    """
    print(f"[EVAL] Evaluation of synthetic samples generated by {method_string}:")
    # eval_pcoa = PCOA(healthy_prop, synth_prop, method_string,fraction=1, random_state=42)
    # print(f"  - Variance explained by first two PCoA axes: {eval_pcoa['variance_explained']}")
    # print(f"  - Number of real (healthy) samples: {eval_pcoa['n_real']}")
    # print(f"  - Number of synthetic samples: {eval_pcoa['n_synth']}")
    # alpha_diversity(healthy_prop, synth_prop, method_string=method_string)
    print(f"[PERMANOVA] Evaluation of synthetic samples generated by {method_string}:")
    permanova_t = permanova_subsamples(healthy_prop, synth_prop, method_string=method_string,
                          subsets=5, synth_ratio=5, permutations=999,
                         random_state=42, metric="braycurtis")
    
    


def PCOA(healthy_prop, synth_prop, method_string, fraction=1, random_state=42):
    """
    Compute PCoA (Bray–Curtis), plot real vs synthetic with fixed colors, and save to file.
    Returns a result dict with path, variance explained, and counts.
    """
    # Require a non-empty method_string for filename consistency
    if not isinstance(method_string, str) or method_string.strip() == "":
        raise ValueError("method_string must be a non-empty string (used in the saved filename).")

    healthy_prop = np.asarray(healthy_prop, dtype=float)
    synth_prop   = np.asarray(synth_prop, dtype=float)
    
    # Per-class subsample: fraction% of each class. random_state for reproducibility
    rng = np.random.default_rng(random_state)
    # Subsample healthy_prop to fraction%
    n_healthy = healthy_prop.shape[0]       
    n_subsample = max(1, int(n_healthy * fraction))
    subsample_indices = rng.choice(n_healthy, size=n_subsample, replace=False)  
    healthy_prop = healthy_prop[subsample_indices]
    # Subsample synth_prop to fraction%
    n_synth = synth_prop.shape[0]   
    n_subsample = max(1, int(n_synth * fraction))
    subsample_indices = rng.choice(n_synth, size=n_subsample, replace=False)
    synth_prop = synth_prop[subsample_indices]
    # print sizes after subsampling
    print(f"[PCoA] After subsampling to fraction={fraction}: healthy_prop shape: {healthy_prop.shape}, synth_prop shape: {synth_prop.shape}")

    # Concatenate samples and build labels: 0=real, 1=synthetic
    X = np.vstack([healthy_prop, synth_prop])
    labels = np.array([0] * len(healthy_prop) + [1] * len(synth_prop))

    # Bray–Curtis distance matrix
    D = squareform(pdist(X, metric="braycurtis"))
    dm = DistanceMatrix(D)

    # PCoA
    ord_res = pcoa(dm)
    coords = ord_res.samples.values
    explained = ord_res.proportion_explained

    # Plot with fixed colors
    fig, ax = plt.subplots(figsize=(7, 6), dpi=140)
    ax.scatter(
        coords[labels == 1, 0], coords[labels == 1, 1],
        s=24, alpha=0.75, label="synthetic", color="tab:red"
    )
    ax.scatter(
        coords[labels == 0, 0], coords[labels == 0, 1],
        s=24, alpha=0.9, label="real (healthy)", color="tab:blue"
    )
    
    ax.set_xlabel(f"PCoA1 ({explained[0]*100:.1f}%)")
    ax.set_ylabel(f"PCoA2 ({explained[1]*100:.1f}%)")
    ax.set_title(f"PCoA (Bray–Curtis) — {method_string}")
    ax.legend(frameon=True)
    ax.grid(True, alpha=0.25)
    plt.tight_layout()

    # Save: method name + timestamp only
    base_dir = Path(__file__).resolve().parent
    out_dir = base_dir / "PCOA"
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    out_path = out_dir / f"pcoa_{method_string}_{ts}.png"
    plt.savefig(out_path, bbox_inches="tight")
    plt.close(fig)

    print(f"[PCoA] Saved PCoA plot to: {out_path}")

    return {
        "variance_explained": explained[:2].tolist(),
        "n_real": int((labels == 0).sum()),
        "n_synth": int((labels == 1).sum())
    }

def alpha_diversity(healthy_prop, synth_prop, method_string=""):
    """
    Compute and compare alpha-diversity metrics for real (healthy_prop) vs synthetic (synth_prop),
    print group summaries, and save a simple boxplot figure.

    Metrics per sample:
      - Shannon entropy (natural log)
      - Simpson diversity (1 - sum(p^2))
      - Richness (#features > 0)
      - Pielou's evenness (H / log(richness), defined when richness >= 2)

    Returns
    -------
    dict with per-group mean±std for each metric, Cohen's d, and the saved plot path.
    """
 
    # Per-sample metrics (arrays)
    Hr, Sr, Rr, Jr = _alpha_metrics_per_sample(healthy_prop)   # real
    Hs, Ss, Rs, Js = _alpha_metrics_per_sample(synth_prop)     # synthetic

    # Summaries + effect sizes
    results = {
        "shannon": {
            "real_mean_std":      _mean_std(Hr),
            "synthetic_mean_std": _mean_std(Hs),
            "cohens_d":           _cohens_d(Hr, Hs),
        },
        "simpson": {
            "real_mean_std":      _mean_std(Sr),
            "synthetic_mean_std": _mean_std(Ss),
            "cohens_d":           _cohens_d(Sr, Ss),
        },
        "richness": {
            "real_mean_std":      _mean_std(Rr),
            "synthetic_mean_std": _mean_std(Rs),
            "cohens_d":           _cohens_d(Rr, Rs),
        },
        "evenness": {
            "real_mean_std":      _mean_std(Jr),
            "synthetic_mean_std": _mean_std(Js),
            "cohens_d":           _cohens_d(Jr, Js),
        },
        "n_real":  int(len(Hr)),
        "n_synth": int(len(Hs)),
    }

    print(f"[ALPHA] Alpha diversity : {method_string}")
    for name, key in [("Shannon", "shannon"), ("Simpson", "simpson"),
                      ("Richness", "richness"), ("Evenness", "evenness")]:
        r_mean, r_std = results[key]["real_mean_std"]
        s_mean, s_std = results[key]["synthetic_mean_std"]
        d = results[key]["cohens_d"]
        print(f"  - {name:<8} | real: {r_mean:.3f} +- {r_std:.3f} | synth: {s_mean:.3f} +- {s_std:.3f} | d={d:.2f}")

    # Boxplots
    fig, axs = plt.subplots(1, 4, figsize=(14, 3.8), dpi=130)
    axs[0].boxplot([Hr, Hs], labels=["real", "synthetic"], showfliers=False); axs[0].set_title("Shannon")
    axs[1].boxplot([Sr, Ss], labels=["real", "synthetic"], showfliers=False); axs[1].set_title("Simpson (1 - Σp²)")
    axs[2].boxplot([Rr, Rs], labels=["real", "synthetic"], showfliers=False); axs[2].set_title("Richness (#>0)")
    axs[3].boxplot([Jr, Js], labels=["real", "synthetic"], showfliers=False); axs[3].set_title("Pielou's evenness")
    for ax in axs: ax.grid(True, alpha=0.25)
    fig.suptitle(f"Alpha diversity — {method_string}", y=1.03)
    plt.tight_layout()

    base_dir = Path(__file__).resolve().parent
    out_dir  = base_dir / "ALPHA"
    out_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    safe_method = (method_string or "method").replace("/", "_")
    out_path = out_dir / f"alpha_{safe_method}_{ts}.png"
    plt.savefig(out_path, bbox_inches="tight")
    plt.close(fig)
    print(f"  [ALPHA] Saved plot to: {out_path}")

    return {"alpha_results": results, "alpha_plot_path": str(out_path)}


# ---------------------- helpers (defined below the main function) ----------------------

def _renorm_rows(X):
    """Row-normalize to sum=1 (rows with sum=0 stay as-is)."""
    import numpy as np
    X = np.asarray(X, dtype=float)
    rs = X.sum(axis=1, keepdims=True)           # (n, 1)
    rs_safe = np.where(rs > 0.0, rs, 1.0)       # avoid divide-by-zero
    return X / rs_safe                          # broadcasts (n,d)/(n,1)



def _alpha_metrics_per_sample(X):
    """
    Compute per-sample alpha-diversity: Shannon, Simpson, Richness, Evenness.
    Assumes rows sum to ~1; re-normalizes just in case.
    """
    with np.errstate(divide='ignore', invalid='ignore'):
        X = _renorm_rows(X)

        # Richness: count positive entries
        richness = (X > 0).sum(axis=1).astype(float)

        # Shannon entropy (natural log); ignore zeros to avoid log(0)
        P = np.where(X > 0, X, np.nan)
        H = -np.nansum(P * np.log(P), axis=1)

        # Simpson diversity = 1 - sum(p^2)
        simpson = 1.0 - np.sum(X**2, axis=1)

        # Pielou's evenness = H / log(richness) when richness >= 2; else 0
        denom = np.log(np.maximum(richness, 1.0))
        evenness = np.where(richness >= 2.0, H / denom, 0.0)

    return H, simpson, richness, evenness


def _mean_std(a):
    """Return (mean, std) as floats."""
    a = np.asarray(a, dtype=float)
    return float(np.nanmean(a)), float(np.nanstd(a, ddof=1))


def _cohens_d(a, b):
    """Cohen's d (pooled std)."""
    a = np.asarray(a, float); b = np.asarray(b, float)
    ma, mb = np.nanmean(a), np.nanmean(b)
    sa, sb = np.nanstd(a, ddof=1), np.nanstd(b, ddof=1)
    na, nb = len(a), len(b)
    sp_num = (na - 1) * sa**2 + (nb - 1) * sb**2
    sp_den = max(na + nb - 2, 1)
    sp = np.sqrt(sp_num / sp_den) if sp_den > 0 else 1.0
    sp = sp if sp > 1e-12 else 1e-12
    return float((ma - mb) / sp)

def permanova_test(healthy_prop, synth_prop, method_string="",
                   permutations=999, random_state=42, metric="braycurtis"):
    """
    Two-group PERMANOVA (real vs synthetic) using a distance matrix (default: Bray–Curtis).
    Assumes inputs are valid and random_state is always provided.

    Returns a dict with F, p-value, permutations, sizes, metric, and saved report path.
    """

    # Reproducible permutations (scikit-bio uses NumPy's global RNG)
    np.random.seed(int(random_state))

    # Concatenate and label groups
    H = np.asarray(healthy_prop, dtype=float)
    S = np.asarray(synth_prop,   dtype=float)
    X = np.vstack([H, S])
    grouping = np.array(["real"] * H.shape[0] + ["synthetic"] * S.shape[0])

    # Distance matrix
    D = squareform(pdist(X, metric=metric))
    dm = DistanceMatrix(D, ids=[f"s{i}" for i in range(X.shape[0])])

    # PERMANOVA
    res = permanova(dm, grouping=grouping, permutations=int(permutations))

    # Compatible with both return types: object (newer) or pandas.Series (older)
    try:
        F_val = float(res.statistic)
        p_val = float(res.p_value)
        perms = int(res.permutations)
    except AttributeError:
        F_val = float(res["test statistic"])
        p_val = float(res["p-value"])
        perms = int(res.get("permutations", res["number of permutations"]))


    # Print concise summary
    print(f"[PERMANOVA|{metric}] F={F_val:.4f} | p={p_val:.4g} | perms={perms} "
          f"| n_real={H.shape[0]}, n_synth={S.shape[0]} — {method_string}")

    # Save a tiny text report
    out_dir = Path(__file__).resolve().parent / "PERMANOVA"
    out_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    out_path = out_dir / f"permanova_{method_string}_{ts}.txt"

    with open(out_path, "w", encoding="utf-8") as fh:
        fh.write(f"PERMANOVA ({metric}) {method_string}\n")
        fh.write(f"F statistic: {F_val:.6f}\n")
        fh.write(f"p-value: {p_val:.6g}\n")
        fh.write(f"permutations: {perms}\n")
        fh.write(f"n_real: {H.shape[0]}\n")
        fh.write(f"n_synth: {S.shape[0]}\n")

    return {
        "statistic_F": F_val,
        "p_value": p_val,
        "permutations": perms,
        "metric": metric,
        "n_real": int(H.shape[0]),
        "n_synth": int(S.shape[0]),
        "report_path": str(out_path),
    }

def permanova_subsamples(healthy_prop, synth_prop, method_string="",
                         subsets=5, synth_ratio=5, permutations=999,
                         random_state=42, metric="braycurtis"):
    """
    Run PERMANOVA (Bray–Curtis by default) on multiple balanced subsamples of the synthetic group.

    - Takes 5 (default) independent subsamples of size: n_synth_per_subset = min(synth_ratio * n_real, n_synth_total).
    - For each subset: real vs synthetic PERMANOVA with 'permutations'.
    - Saves a plain-text report with all runs and a short summary.

    Returns a dict with the saved report path and basic metadata.
    """
    import numpy as np
    from pathlib import Path
    from datetime import datetime
    from scipy.spatial.distance import pdist, squareform
    from skbio.stats.distance import DistanceMatrix, permanova

    rng = np.random.default_rng(int(random_state))

    H = np.asarray(healthy_prop, dtype=float)
    S = np.asarray(synth_prop,   dtype=float)

    n_real = H.shape[0]
    n_synth_total = S.shape[0]
    n_synth_sample = min(int(synth_ratio * n_real), n_synth_total)

    results = []
    for i in range(int(subsets)):
        idx_s = rng.choice(n_synth_total, size=n_synth_sample, replace=False)
        X = np.vstack([H, S[idx_s]])
        grouping = np.array(["real"] * n_real + ["synthetic"] * n_synth_sample)

        # distance matrix
        D = squareform(pdist(X, metric=metric))
        dm = DistanceMatrix(D, ids=[f"s{j}" for j in range(X.shape[0])])

        # reproducible permutations per subset
        np.random.seed(int(rng.integers(0, 2**32 - 1)))
        res = permanova(dm, grouping=grouping, permutations=int(permutations))

        # robust extraction (Series or object)
        try:
            F_val = float(res.statistic)
            p_val = float(res.p_value)
            perms = int(res.permutations)
        except AttributeError:
            F_val = float(res["test statistic"])
            p_val = float(res["p-value"])
            perms = int(res.get("permutations", res["number of permutations"]))

        # approximate R^2 for k=2 groups
        N = X.shape[0]
        R2 = (F_val * 1.0) / (F_val * 1.0 + (N - 2))

        results.append((F_val, p_val, perms, n_real, n_synth_sample, R2))

    # save report
    out_dir = Path(__file__).resolve().parent / "PERMANOVA"
    out_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    safe_method = (method_string or "method").replace("/", "_")
    out_path = out_dir / f"permanova_subsamples_{safe_method}_{ts}.txt"

    with open(out_path, "w", encoding="utf-8") as fh:
        fh.write(f"PERMANOVA subsamples ({metric}) - {method_string}\n")
        fh.write(f"subsets: {subsets}, synth_ratio: {synth_ratio}, permutations: {permutations}\n")
        for k, (F_val, p_val, perms, nr, ns, R2) in enumerate(results, 1):
            fh.write(f"subset {k}: F={F_val:.6f}, p={p_val:.6g}, R2~={R2:.6f}, n_real={nr}, n_synth={ns}, perms={perms}\n")
        F_mean = float(np.mean([r[0] for r in results]))
        R2_mean = float(np.mean([r[5] for r in results]))
        p_lt_05 = int(np.sum([r[1] < 0.05 for r in results]))
        fh.write(f"summary: F_mean={F_mean:.6f}, R2_mean~={R2_mean:.6f}, p<0.05 in {p_lt_05}/{subsets}\n")

    print(f"[PERMANOVA] Saved subsample report to: {out_path}")

    return {
        "report_path": str(out_path),
        "n_subsets": int(subsets),
        "n_real": int(n_real),
        "n_synth_per_subset": int(n_synth_sample),
        "permutations": int(permutations),
        "metric": metric,
    }
