from pathlib import Path
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import pdist, squareform
from skbio.stats.ordination import pcoa
from skbio import DistanceMatrix

def eval_healthy_and_synthetic(healthy_prop, synth_prop, eps_vec=None, method_string="", fraction=1, random_state=42):
    """
    Evaluate and print statistics comparing healthy_prop and synth_prop.
    Currently dispatches to PCOA evaluation.
    """
    print(f"[EVAL] Evaluation of synthetic samples generated by {method_string}:")
    eval_pcoa = PCOA(healthy_prop, synth_prop, method_string,fraction=1, random_state=42)
    print(f"  - Variance explained by first two PCoA axes: {eval_pcoa['variance_explained']}")
    print(f"  - Number of real (healthy) samples: {eval_pcoa['n_real']}")
    print(f"  - Number of synthetic samples: {eval_pcoa['n_synth']}")

    


def PCOA(healthy_prop, synth_prop, method_string, fraction=1, random_state=42):
    """
    Compute PCoA (Bray–Curtis), plot real vs synthetic with fixed colors, and save to file.
    Returns a result dict with path, variance explained, and counts.
    """
    # print sizes of inputs
    print(f"[EVAL] PCOA input sizes: healthy_prop shape: {healthy_prop.shape}, synth_prop shape: {synth_prop.shape}")
    # Require a non-empty method_string for filename consistency
    if not isinstance(method_string, str) or method_string.strip() == "":
        raise ValueError("method_string must be a non-empty string (used in the saved filename).")

    healthy_prop = np.asarray(healthy_prop, dtype=float)
    synth_prop   = np.asarray(synth_prop, dtype=float)
    
    # Per-class subsample: fraction% of each class. random_state for reproducibility
    rng = np.random.default_rng(random_state)
    # Subsample healthy_prop to fraction%
    n_healthy = healthy_prop.shape[0]       
    n_subsample = max(1, int(n_healthy * fraction))
    subsample_indices = rng.choice(n_healthy, size=n_subsample, replace=False)  
    healthy_prop = healthy_prop[subsample_indices]
    # Subsample synth_prop to fraction%
    n_synth = synth_prop.shape[0]   
    n_subsample = max(1, int(n_synth * fraction))
    subsample_indices = rng.choice(n_synth, size=n_subsample, replace=False)
    synth_prop = synth_prop[subsample_indices]
    # print sizes after subsampling
    print(f"[EVAL] After subsampling to fraction={fraction}: healthy_prop shape: {healthy_prop.shape}, synth_prop shape: {synth_prop.shape}")

    # Concatenate samples and build labels: 0=real, 1=synthetic
    X = np.vstack([healthy_prop, synth_prop])
    labels = np.array([0] * len(healthy_prop) + [1] * len(synth_prop))

    # Bray–Curtis distance matrix
    D = squareform(pdist(X, metric="braycurtis"))
    dm = DistanceMatrix(D)

    # PCoA
    ord_res = pcoa(dm)
    coords = ord_res.samples.values
    explained = ord_res.proportion_explained

    # Plot with fixed colors
    fig, ax = plt.subplots(figsize=(7, 6), dpi=140)
    ax.scatter(
        coords[labels == 1, 0], coords[labels == 1, 1],
        s=24, alpha=0.75, label="synthetic", color="tab:red"
    )
    ax.scatter(
        coords[labels == 0, 0], coords[labels == 0, 1],
        s=24, alpha=0.9, label="real (healthy)", color="tab:blue"
    )
    
    ax.set_xlabel(f"PCoA1 ({explained[0]*100:.1f}%)")
    ax.set_ylabel(f"PCoA2 ({explained[1]*100:.1f}%)")
    ax.set_title(f"PCoA (Bray–Curtis) — {method_string}")
    ax.legend(frameon=True)
    ax.grid(True, alpha=0.25)
    plt.tight_layout()

    # Save: method name + timestamp only
    base_dir = Path(__file__).resolve().parent
    out_dir = base_dir / "PCOA"
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    out_path = out_dir / f"pcoa_{method_string}_{ts}.png"
    plt.savefig(out_path, bbox_inches="tight")
    plt.close(fig)

    print(f"[EVAL] Saved PCoA plot to: {out_path}")

    return {
        "variance_explained": explained[:2].tolist(),
        "n_real": int((labels == 0).sum()),
        "n_synth": int((labels == 1).sum())
    }
